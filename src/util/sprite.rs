use std::collections::HashMap;

use crate::graphics::texture::Texture;

use super::repository::ResourceId;

/// Contains information on how to render a specific animation
/// from a larger texture with multiple animations bundled together.
#[derive(Debug, Clone, Copy)]
pub struct Sprite {
    /// Texture this sprite comes from.
    pub texture: ResourceId<Texture>,
    /// Top left uv coordinate.
    pub uv_topleft: glam::Vec2,
    /// UV width and height.
    pub uv_dims: glam::Vec2,
    /// Sprite dimensions in pixels.
    pub sprite_dims: glam::UVec2,
    /// Number of frames in this sprite.
    pub frame_count: usize,
}

impl Sprite {
    pub fn get_uv_window(&self, frame: usize) -> [f32; 4] {
        let modded_frame = frame % self.frame_count;
        [
            self.uv_topleft.x + (self.uv_dims.x * modded_frame as f32),
            self.uv_topleft.y,
            self.uv_dims.x,
            self.uv_dims.y,
        ]
    }
}

// ####################################
// For deserializing the Aseprite file
// ####################################
#[derive(serde::Deserialize)]
struct Tag {
    name: Option<String>,
    from: usize,
    to: usize,
}

#[derive(serde::Deserialize)]
struct Frame {
    x: u32,
    y: u32,
    w: u32,
    h: u32,
}
// ####################################

/// Return type of [load_aseprite_sprites].
pub struct LoadedSprites {
    /// Filename of the image the sprites came from.
    pub image: String,
    /// Mapping from animation tag to sprite.
    pub sprites: HashMap<Option<String>, Sprite>,
}

/// Loads sprite information from a json content generated by aseprite.
pub fn load_aseprite_sprites(
    raw_json: &str,
    texture: ResourceId<Texture>,
) -> anyhow::Result<LoadedSprites> {
    let json: serde_json::Value = serde_json::from_str(raw_json)?;
    let meta = json.get("meta").unwrap();
    let image = meta.get("image").unwrap().as_str().unwrap();
    let texture_dims = meta
        .get("size")
        .map(|value| glam::DVec2 {
            x: value.get("w").unwrap().as_u64().unwrap() as f64,
            y: value.get("h").unwrap().as_u64().unwrap() as f64,
        })
        .unwrap();

    let frames: Vec<Frame> = json
        .get("frames")
        .unwrap()
        .as_array()
        .unwrap()
        .iter()
        .map(|value| serde_json::from_value::<Frame>(value.get("frame").unwrap().clone()).unwrap())
        .collect();

    let tag_array = meta.get("frameTags").unwrap().as_array().unwrap();
    let tags: Vec<Tag> = match tag_array.is_empty() {
        true => vec![Tag {
            name: None,
            from: 0,
            to: frames.len() - 1,
        }],
        false => tag_array
            .iter()
            .map(|value| serde_json::from_value::<Tag>(value.clone()).unwrap())
            .collect(),
    };

    let sprites_and_tags = tags.iter().map(|tag| {
        let first_frame = &frames[tag.from];

        let uv_topleft =
            (glam::dvec2(first_frame.x as f64, first_frame.y as f64) / texture_dims).as_vec2();

        let sprite_dims = glam::uvec2(first_frame.w, first_frame.h);
        let uv_dims = (sprite_dims.as_dvec2() / texture_dims).as_vec2();
        let frame_count = tag.to + 1 - tag.from;

        let sprite = Sprite {
            texture,
            uv_topleft,
            uv_dims,
            sprite_dims,
            frame_count,
        };
        (tag.name.clone(), sprite)
    });

    Ok(LoadedSprites {
        image: image.to_string(),
        sprites: HashMap::from_iter(sprites_and_tags),
    })
}

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn test_load_basic() {
//         const RAW_JSON: &str = include_str!("./test_files/aseprite_basic.json");

//         // et loaded_sprites = load_aseprite_sprites(RAW_JSON);
//     }
// }
